import os
import traceback
from typing import Dict, Tuple, Callable, Type, List, Any
from urllib.parse import urlparse
from browserstack_sdk.sdk_cli.automation_framework import (
    AutomationFramework,
    AutomationFrameworkBrowser,
    AutomationFrameworkState,
    HookState,
)
import copy
from datetime import datetime, timezone, timedelta
from bstack_utils.performance_tester import PerformanceTester
from bstack_utils.constants import EVENTS
class SeleniumFramework(AutomationFramework):
    ENV_BROWSERSTACK_PLATFORM_INDEX = "BROWSERSTACK_PLATFORM_INDEX"

    NAME = "selenium"
    KEY_HUB_URL = "hub_url"
    KEY_FRAMEWORK_SESSION_ID = "framework_session_id"
    KEY_INPUT_CAPABILITIES = "input_capabilities"
    KEY_CAPABILITIES = "capabilities"
    KEY_IS_BROWSERSTACK_HUB = "is_browserstack_hub"
    KEY_STARTED_AT = "started_at"
    KEY_ENDED_AT = "ended_at"
    KEY_PLATFORM_INDEX = "platform_index"

    COMMAND_NEW_SESSION = "newsession"
    COMMAND_GET = "get"
    COMMAND_SCREENSHOT = "screenshot"
    COMMAND_W3C_EXECUTE_SCRIPT = "w3cexecutescript"
    COMMAND_W3C_EXECUTE_SCRIPT_ASYNC = "w3cexecutescriptasync"
    COMMAND_QUIT = "quit"

    hook_regsitry: Dict[str, List[Callable]] = dict()

    browserstack_hub_url: str
    platform_index: int
    options: Any
    desired_capabilities: Any
    helper_methods: Any
    config_capabilities: Dict

    def __init__(
        self,
        browserstack_hub_url: str,
        platform_index: int,
        framework_name: str,
        framework_version: str,
        classes: List[Type],
        helper_methods: Dict[str, Any],
        methods=["__init__", "start_session", "execute", "quit"],
    ):
        super().__init__(
            framework_name,
            framework_version,
            classes,
        )
        self.browserstack_hub_url = browserstack_hub_url
        self.platform_index = platform_index
        # self.config_capabilities = options.to_capabilities() if callable(getattr(options, "to_capabilities")) else None
        # self.options = options
        # self.desired_capabilities = None
        self.track_methods(methods)
        self.helper_methods = helper_methods

    @staticmethod
    def session_id(target: object, strict=True):
        return AutomationFramework.get_data(SeleniumFramework.KEY_FRAMEWORK_SESSION_ID, target, strict)

    @staticmethod
    def hub_url(target: object, strict=True):
        return AutomationFramework.get_data(SeleniumFramework.KEY_HUB_URL, target, strict)

    @staticmethod
    def input_capabilities(target: object, strict=True):
        return AutomationFramework.get_data(SeleniumFramework.KEY_INPUT_CAPABILITIES, target, strict)

    @staticmethod
    def capabilities(target: object, strict=True):
        return AutomationFramework.get_data(SeleniumFramework.KEY_CAPABILITIES, target, strict)

    @staticmethod
    def is_instance_browserstack_hub(instance: AutomationFrameworkBrowser) -> bool:
        return AutomationFramework.get_state(instance, SeleniumFramework.KEY_IS_BROWSERSTACK_HUB, False)

    @staticmethod
    def instance_hub_url(instance: AutomationFrameworkBrowser, default_value=None):
        return AutomationFramework.get_state(instance, SeleniumFramework.KEY_HUB_URL, default_value)

    @staticmethod
    def instance_capabilities(instance: AutomationFrameworkBrowser, default_value=None):
        return AutomationFramework.get_state(instance, SeleniumFramework.KEY_CAPABILITIES, default_value)

    @staticmethod
    def is_browserstack_hub(hub_url: str, browserstack_domain=".browserstack.com"):
        try:
            hub_domain = str(urlparse(hub_url).netloc) if hub_url else None
            return hub_domain.endswith(browserstack_domain)
        except:
            pass
        return False

    @staticmethod
    def is_execute_request(method_name: str):
        return method_name == "execute"

    @staticmethod
    def is_new_session_command(method_name: str, *args):
        return (
            SeleniumFramework.is_execute_request(method_name)
            and SeleniumFramework.command_name_lower(*args) == SeleniumFramework.COMMAND_NEW_SESSION
        )

    @staticmethod
    def is_browserstack_script_command(method_name: str, *args):
        if not SeleniumFramework.is_execute_request(method_name):
            return False

        if not SeleniumFramework.COMMAND_W3C_EXECUTE_SCRIPT in SeleniumFramework.command_name_lower(*args):
            return False

        command_params = SeleniumFramework.parse_command_params(*args)
        return command_params and "script" in command_params and "browserstack_executor" in command_params["script"]

    @staticmethod
    def is_accessibility_script_command(method_name: str, *args):
        if not SeleniumFramework.is_execute_request(method_name):
            return False

        if not SeleniumFramework.COMMAND_W3C_EXECUTE_SCRIPT in SeleniumFramework.command_name_lower(*args):
            return False

        command_params = SeleniumFramework.parse_command_params(*args)
        return (
            command_params
            and "script" in command_params
            and "browserstack_accessibility_automation_script" in command_params["script"]
        )

    @staticmethod
    def command_name_lower(*args):
        return str(SeleniumFramework.parse_command_name(*args)).lower()

    @staticmethod
    def parse_command_name(*args):
        return args[0] if args and type(args) in [list, tuple] and isinstance(args[0], str) else None

    @staticmethod
    def parse_command_params(*args):
        return args[1] if len(args) > 1 and isinstance(args[1], dict) else None

    @staticmethod
    def get_hub_url(driver):
        command_executor = getattr(driver, "command_executor", None)
        if not command_executor:
            return None

        hub_url = str(command_executor) if isinstance(command_executor, (str, bytes)) else None
        hub_url = str(command_executor._url) if not hub_url and getattr(command_executor, "_url", None) else None
        if not hub_url:
            client_config = getattr(command_executor, "_client_config", None)

            if not client_config:
                return None

            hub_url = getattr(client_config, "remote_server_addr", None)

        return hub_url


    def set_hub_url(self, instance, driver, hub_url: str):
        result = False
        if not hub_url:
            return result

        command_executor = getattr(driver, "command_executor", None)
        if command_executor:
            if isinstance(command_executor, (str, bytes)):
                setattr(driver, "command_executor", hub_url)
                result = True
            elif hasattr(command_executor, "_url"):
                setattr(command_executor, "_url", hub_url)
                result = True

        if result:
            self.browserstack_hub_url = hub_url
            SeleniumFramework.set_state(instance, SeleniumFramework.KEY_HUB_URL, hub_url)
            SeleniumFramework.set_state(
                instance, SeleniumFramework.KEY_IS_BROWSERSTACK_HUB, SeleniumFramework.is_browserstack_hub(hub_url)
            )
        return result

    @staticmethod
    def hook_info_to_registry_key(hook_info: Tuple[AutomationFrameworkState, HookState]):
        return ":".join((AutomationFrameworkState(hook_info[0]).name, HookState(hook_info[1]).name))

    @staticmethod
    def set_hook_callback(hook_info: Tuple[AutomationFrameworkState, HookState], callback: Callable):
        hook_registry_key = SeleniumFramework.hook_info_to_registry_key(hook_info)

        if not hook_registry_key in SeleniumFramework.hook_regsitry:
            SeleniumFramework.hook_regsitry[hook_registry_key] = []

        SeleniumFramework.hook_regsitry[hook_registry_key].append(callback)

    def log_benchmark(self, instance: AutomationFrameworkBrowser, method_name: str, time_taken: timedelta, *args, **kwargs):
        if not instance or method_name in ("start_session"):
            return
        cmd = args[0] if method_name == "execute" and args and type(args) in [list, tuple] and isinstance(args[0], str) else None
        benchmark_key = ":".join(map(str, filter(None, [method_name, cmd])))
        instance.add_benchmark("driver:" + benchmark_key, time_taken)

    def on_hook(
        self,
        target: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ) -> Callable[..., Any]:
        instance, method_name = exec
        framework_state, hook_state = hook_info
        hook_registry_key = SeleniumFramework.hook_info_to_registry_key(hook_info)
        self.logger.debug(f"on_hook: method_name={method_name} hook_info={hook_info} args={args} kwargs={kwargs}")
        if framework_state == AutomationFrameworkState.QUIT:
            if hook_state == HookState.PRE:
                random_label = PerformanceTester.mark_start(EVENTS.SDK_DRIVER_QUIT.value)
                AutomationFramework.set_state(instance, EVENTS.SDK_DRIVER_QUIT.value, random_label)
                self.logger.debug("instance={} method_name={} framework_state={} hook_state={}".format(instance, method_name, framework_state, hook_state))
        if framework_state == AutomationFrameworkState.CREATE:
            if hook_state == HookState.POST and not SeleniumFramework.KEY_FRAMEWORK_SESSION_ID in instance.data:
                session_id = getattr(target, "session_id", None)
                if session_id:
                    instance.data[SeleniumFramework.KEY_FRAMEWORK_SESSION_ID] = session_id
        elif (
            framework_state == AutomationFrameworkState.EXECUTE
            and SeleniumFramework.command_name_lower(*args) == SeleniumFramework.COMMAND_NEW_SESSION
        ):
            if hook_state == HookState.PRE:
                hub_url = SeleniumFramework.get_hub_url(target)
                if hub_url:
                    instance.data.update(
                        {
                            SeleniumFramework.KEY_HUB_URL: hub_url,
                            SeleniumFramework.KEY_IS_BROWSERSTACK_HUB: SeleniumFramework.is_browserstack_hub(hub_url),
                            SeleniumFramework.KEY_PLATFORM_INDEX: int(
                                os.environ.get("BROWSERSTACK_PLATFORM_INDEX", str(self.platform_index))
                            ),
                        }
                    )

                command_params = SeleniumFramework.parse_command_params(*args)
                input_capabilities = command_params.get("capabilities", None) if command_params else None

                if isinstance(input_capabilities, dict):
                    # snapshot of original caps
                    instance.data[SeleniumFramework.KEY_INPUT_CAPABILITIES] = copy.deepcopy(input_capabilities)
                    # working copy of caps
                    instance.data[SeleniumFramework.KEY_CAPABILITIES] = input_capabilities
            elif hook_state == HookState.POST:
                if isinstance(result, dict):
                    framework_session_id = result.get("value", dict()).get("sessionId", None)

                    if framework_session_id:
                        instance.data.update(
                            {
                                SeleniumFramework.KEY_FRAMEWORK_SESSION_ID: framework_session_id,
                                SeleniumFramework.KEY_STARTED_AT: datetime.now(tz=timezone.utc),
                            }
                        )
        elif (
            framework_state == AutomationFrameworkState.EXECUTE
            and SeleniumFramework.command_name_lower(*args) == SeleniumFramework.COMMAND_QUIT
            and hook_state == HookState.POST
        ):
            instance.data[SeleniumFramework.KEY_ENDED_AT] = datetime.now(tz=timezone.utc)

        # call all registered hooks eligible for this event after basic selenium data is loaded above
        if hook_registry_key in SeleniumFramework.hook_regsitry:
            callback_result = None

            for callback in SeleniumFramework.hook_regsitry[hook_registry_key]:
                try:
                    new_result = callback(self, target, exec, hook_info, result, *args, **kwargs)
                    if callback_result == None:
                        # first result wins
                        callback_result = new_result
                except Exception as e:
                    self.logger.error(f"error invoking callback: {e}")
                    traceback.print_exc()

            if framework_state == AutomationFrameworkState.QUIT:
                if hook_state == HookState.POST:
                    random_label = AutomationFramework.get_state(instance, EVENTS.SDK_DRIVER_QUIT.value)
                    if random_label!=None:
                        PerformanceTester.end(EVENTS.SDK_DRIVER_QUIT.value, random_label+":start", random_label+":end", True, None)
            if hook_state == HookState.PRE and callable(callback_result):
                # BEFORE hooks may return a function that will wrap actual call
                return callback_result
            elif hook_state == HookState.POST and callback_result:
                # AFTER hooks may return a value that will replace the actual return value
                return callback_result

    def resolve_framework_state(
        self, method_name, previous_state: AutomationFrameworkState, *args, **kwargs
    ) -> AutomationFrameworkState:
        if method_name == "__init__" or method_name == "start_session":
            return AutomationFrameworkState.CREATE

        if method_name == "quit":
            return AutomationFrameworkState.QUIT

        if method_name == "execute":
            if previous_state != AutomationFrameworkState.NONE:
                # we'll determine state based on Selenium commands inside the execute method

                command_name = SeleniumFramework.command_name_lower(*args)
                # following are duplicate states, but should not violate state-machine rules
                if command_name == SeleniumFramework.COMMAND_NEW_SESSION:
                    return AutomationFrameworkState.CREATE

                # TODO: this would mean that while the quit command is requested,
                # other EXECUTE commands will fail if state-transition is strict
                # elif command_name.lower() == "quit":
                #     return AutomationFrameworkState.QUIT

            return AutomationFrameworkState.EXECUTE

        return AutomationFrameworkState.NONE

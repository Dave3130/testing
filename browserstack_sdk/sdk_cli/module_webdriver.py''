import json
import os
import grpc
from browserstack_sdk import sdk_pb2 as structs
from packaging import version
import traceback
from browserstack_sdk.sdk_cli.module_base import BaseModule
from browserstack_sdk.sdk_cli.automation_framework import (
    AutomationFrameworkState,
    HookState,
    AutomationFrameworkBrowser,
)
from browserstack_sdk.sdk_cli.selenium_framework import SeleniumFramework
from datetime import datetime
from typing import Tuple, Any
from bstack_utils.messages import SETUP_COMPLETE
from bstack_utils.measure import measure
from bstack_utils.constants import *
import threading
import os

from bstack_utils.performance_tester import PerformanceTester

class WebDriverModule(BaseModule):
    KEY_REGISTER_INIT = "register_init"
    KEY_REGISTER_START = "register_start"
    KEY_REGISTER_STOP = "register_stop"

    def __init__(self, module_accessibility):
        super().__init__()
        SeleniumFramework.set_hook_callback((AutomationFrameworkState.CREATE, HookState.PRE), self.on_webdriver_init)
        SeleniumFramework.set_hook_callback((AutomationFrameworkState.EXECUTE, HookState.PRE), self.on_init)
        SeleniumFramework.set_hook_callback((AutomationFrameworkState.EXECUTE, HookState.POST), self.on_pre_start)
        SeleniumFramework.set_hook_callback((AutomationFrameworkState.EXECUTE, HookState.POST), self.on_start)
        SeleniumFramework.set_hook_callback((AutomationFrameworkState.QUIT, HookState.POST), self.on_quit)

    def is_enabled(self) -> bool:
        return True

    def on_webdriver_init(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        instance, method_name = exec
        if method_name != "__init__":
            return

        def wrapped(driver, init, *args, **kwargs):
            url = None
            try:
                if isinstance(kwargs.get("command_executor"), str):
                    url = kwargs.get("command_executor")
                elif hasattr(kwargs.get("command_executor"), '_client_config'):
                    url = kwargs.get("command_executor")._client_config.remote_server_addr
                else:
                    url = kwargs.get("command_executor")._url
            except Exception as e:
                url = ''
                self.logger.error("Error while getting url from driver: {}".format(e))
            self.logger.info("Remote Server Address being passed as : {}".format(str(url)))
            self.update_kwargs(instance, url, f, kwargs)
            self.logger.info("driver.{method_name} platform_index={platform_index}: args={args} kwargs={kwargs}".format(method_name=method_name, platform_index=f.platform_index, args=args, kwargs=kwargs))
            threading.current_thread().bstackSessionDriver = driver
            return init(driver, *args, **kwargs)
        return wrapped


    def on_init(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        instance, method_name = exec
        if f.get_state(instance, WebDriverModule.KEY_REGISTER_INIT, False):
            return

        if not f.has_state(instance, SeleniumFramework.KEY_PLATFORM_INDEX):
            return

        platform_index = f.get_state(instance, SeleniumFramework.KEY_PLATFORM_INDEX)
        if f.is_new_session_command(method_name, *args) and len(args) > 1:
            time_start = datetime.now()
            hub_url = SeleniumFramework.hub_url(driver)
            self.logger.warning(f"hub_url={hub_url}")
            src_capabilities = args[1]["capabilities"] if isinstance(args[1], dict) and "capabilities" in args[1] else None
            caps_key = "alwaysMatch"

            if isinstance(src_capabilities, dict):
                # send_capabilities = (
                #     json.dumps(src_capabilities.get(caps_key, src_capabilities)) if src_capabilities else json.dumps({})
                # ).encode("utf-8")
                # instance.add_benchmark("json:send_capabilities", datetime.now() - time_start)

                time_start = datetime.now()
                r = self.register_init(
                    instance.ref(),
                    platform_index,
                    f.framework_name,
                    f.framework_version,
                    hub_url
                )
                instance.add_benchmark("grpc:register_init", datetime.now() - time_start)

                try:
                    if not r.success:
                        self.logger.info(f"something went wrong: {r}")
                        return

                    if r.hub_url:
                        f.set_hub_url(instance, driver, r.hub_url)

                    # if r.capabilities:
                    #     time_start = datetime.now()
                    #     new_capabilities = json.loads(r.capabilities.decode("utf-8"))
                    #     instance.add_benchmark("json:new_capabilities", datetime.now() - time_start)
                    #
                    #     if isinstance(new_capabilities, dict):
                    #         # TODO: fix this, this is coming from options.to_capabilities()
                    #         desired_capabilities = SeleniumFramework.capabilities(driver)
                    #         if isinstance(desired_capabilities, dict):
                    #             desired_capabilities.clear()
                    #             desired_capabilities.update(new_capabilities.get(caps_key, new_capabilities))
                    #
                    #         if isinstance(src_capabilities, dict):
                    #             src_capabilities.clear()
                    #             src_capabilities.update(new_capabilities if caps_key in new_capabilities else { caps_key: new_capabilities })
                    #         self.logger.warning(f"newsession: platform_index={f.platform_index} new_capabilities={len(r.capabilities)} vs. {len(send_capabilities)}")
                        f.set_state(instance, WebDriverModule.KEY_REGISTER_INIT, True)
                except Exception as e:
                    self.logger.error("error", e)

    def on_pre_start(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
            session_id = SeleniumFramework.session_id(driver)
            if session_id:
                start_label = "{}:start".format(session_id)
                PerformanceTester.mark(start_label)

    def on_start(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        instance = exec[0]
        if f.get_state(instance, WebDriverModule.KEY_REGISTER_START, False):
            return

        ref = instance.ref()
        hub_url = SeleniumFramework.hub_url(driver)

        if not hub_url:
            self.logger.warning(f"failed to parse hub_url={hub_url}")
            return

        framework_session_id = SeleniumFramework.session_id(driver)
        if not framework_session_id:
            self.logger.warning(f"failed to parse framework_session_id={framework_session_id}")
            return

        if SeleniumFramework.command_name_lower(*args) == SeleniumFramework.COMMAND_NEW_SESSION:
            
            end_label = "{}:end".format(framework_session_id)
            start_label = "{}:start".format(framework_session_id)
            PerformanceTester.end(
                label="sdk:driver:post-initialization",
                start=start_label,
                end=end_label,
                status=True,
                failure=None
            )

            time_start = datetime.now()
            r = self.register_start(
                ref,
                f.get_state(instance, SeleniumFramework.KEY_PLATFORM_INDEX, 0),
                f.framework_name,
                f.framework_version,
                framework_session_id,
                hub_url,
            )
            instance.add_benchmark("grpc:register_start", datetime.now() - time_start)
            f.set_state(instance, WebDriverModule.KEY_REGISTER_START, r.success)

    def on_quit(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        instance = exec[0]
        if f.get_state(instance, WebDriverModule.KEY_REGISTER_STOP, False):
            return

        ref = instance.ref()
        framework_session_id = SeleniumFramework.session_id(driver)
        hub_url = SeleniumFramework.hub_url(driver)

        time_start = datetime.now()
        r = self.register_stop(
            ref,
            f.get_state(instance, SeleniumFramework.KEY_PLATFORM_INDEX, 0),
            f.framework_name,
            f.framework_version,
            framework_session_id,
            hub_url,
        )
        instance.add_benchmark("grpc:register_stop", datetime.now() - time_start)
        f.set_state(instance, WebDriverModule.KEY_REGISTER_STOP, r.success)

    @measure(event_name=EVENTS.SDK_DRIVER_GET, stage=STAGE.SINGLE)
    def register_webdriver_init(self, platform_index: int, url: str, ref, user_input_params: bytes):
        req = structs.DriverInitRequest()
        req.bin_session_id = self.bin_session_id
        req.platform_index = platform_index
        req.user_input_params = user_input_params
        req.ref = ref
        req.hub_url = url
        self.logger.debug(f"register_webdriver_init: {req}")

        try:
            r = self.cli_service.DriverInit(req)
            if not r.success:
                self.logger.debug(f"received from server: success={r.success}")
            return r
        except grpc.RpcError as e:
            self.logger.error(f"rpc-error: {e}")
            traceback.print_exc()
            raise e

    @measure(event_name=EVENTS.SDK_AUTOMATION_FRAMEWORK_INIT, stage=STAGE.SINGLE)
    def register_init(
        self,
        ref: str,
        platform_index: int,
        framework_name: str,
        framework_version: str,
        hub_url: str
    ):
        self.ensure_bin_session()
        req = structs.AutomationFrameworkInitRequest()
        req.ref = ref
        req.bin_session_id = self.bin_session_id
        req.platform_index = platform_index
        req.framework_name = framework_name
        req.framework_version = framework_version
        req.hub_url = hub_url
        self.logger.debug(f"register_init: {req}")

        try:
            r = self.cli_service.AutomationFrameworkInit(req)
            if not r.success:
                self.logger.debug(f"received from server: success={r.success}")
            return r
        except grpc.RpcError as e:
            self.logger.error(f"rpc-error: {e}")
            traceback.print_exc()
            raise e

    @measure(event_name=EVENTS.SDK_AUTOMATION_FRAMEWORK_START, stage=STAGE.SINGLE)
    def register_start(
        self,
        ref: str,
        platform_index: int,
        framework_name: str,
        framework_version: str,
        framework_session_id: str,
        hub_url: str,
    ):
        self.ensure_bin_session()
        req = structs.AutomationFrameworkStartRequest()
        req.ref = ref
        req.bin_session_id = self.bin_session_id
        req.platform_index = platform_index
        req.framework_name = framework_name
        req.framework_version = framework_version
        req.framework_session_id = framework_session_id
        req.hub_url = hub_url
        self.logger.debug(f"register_start: {req}")

        try:
            r = self.cli_service.AutomationFrameworkStart(req)
            if not r.success:
                self.logger.debug(f"received from server: {r}")
            return r
        except grpc.RpcError as e:
            self.logger.error(f"rpc-error: {e}")
            traceback.print_exc()
            raise e

    @measure(event_name=EVENTS.SDK_AUTOMATION_FRAMEWORK_STOP, stage=STAGE.SINGLE)
    def register_stop(
        self,
        ref: str,
        platform_index: int,
        framework_name: str,
        framework_version: str,
        framework_session_id: str,
        hub_url: str,
    ):
        self.ensure_bin_session()
        req = structs.AutomationFrameworkStopRequest()
        req.ref = ref
        req.bin_session_id = self.bin_session_id
        req.platform_index = platform_index
        req.framework_name = framework_name
        req.framework_version = framework_version
        req.framework_session_id = framework_session_id
        req.hub_url = hub_url
        self.logger.debug(f"register_stop: {req}")

        try:
            r = self.cli_service.AutomationFrameworkStop(req)
            if not r.success:
                self.logger.debug(f"received from server: {r}")
            return r
        except grpc.RpcError as e:
            self.logger.error(f"rpc-error: {e}")
            traceback.print_exc()
            raise e

    # @measure(event_name=EVENTS.SDK_FIND_NEAREST_HUB, stage=STAGE.SINGLE)
    # def find_nearest_hub(self):
    #     self.ensure_bin_session()
    #     req = structs.FindNearestHubRequest()
    #     req.bin_session_id = self.bin_session_id

    #     try:
    #         r = self.cli_service.FindNearestHub(req)
    #         self.logger.debug(f"received from server: {r}")
    #     except grpc.RpcError as e:
    #         self.logger.error(f"rpc-error: {e}")
    #         traceback.print_exc()
    #         raise e

    @measure(event_name=EVENTS.SDK_PRE_INITIALIZE, stage=STAGE.SINGLE)
    def update_kwargs(self, instance: AutomationFrameworkBrowser, url: str, f: SeleniumFramework, kwargs):
        selenium_version = version.parse(f.framework_version)

        options_from_user = kwargs.get("options")
        desired_capabilities_from_user = kwargs.get("desired_capabilities")

        final_capabilities = {}
        final_desired_capabilities = {}
        final_options = None

        user_params = {}

        if desired_capabilities_from_user is not None or options_from_user is not None: # check top level caps
            if desired_capabilities_from_user is not None:
                user_params['desired_capabilities'] = desired_capabilities_from_user
            if options_from_user is not None and callable(getattr(options_from_user, "to_capabilities")):
                user_params['options_as_capabilities'] = options_from_user.to_capabilities()

        response = self.register_webdriver_init(f.platform_index, url, instance.ref(), json.dumps(user_params).encode("utf-8"))

        if response is not None and response.capabilities:
            final_capabilities = json.loads(response.capabilities.decode("utf-8"))
            if not final_capabilities: # empty caps means either browserstackAutomation false or error in processing
                return

            final_options = f.helper_methods["create_options_from_caps"](final_capabilities)

        if options_from_user is not None and selenium_version >= version.parse('3.8.0'):
            final_desired_capabilities = None

        if (
                not options_from_user and not desired_capabilities_from_user
        ) or (
                selenium_version < version.parse('3.8.0')
        ):
            final_desired_capabilities = {}
            final_desired_capabilities.update(final_capabilities)

        self.logger.info(SETUP_COMPLETE)

        if os.environ.get("BROWSERSTACK_AUTOMATION").lower().__eq__("true"):
            kwargs.update(
                {
                    "command_executor": f.browserstack_hub_url,
                }
            )

        if selenium_version >= version.parse('4.10.0'):
            if desired_capabilities_from_user is not None:
                # user passed desired_caps is already merged in CLI in the register_webdriver_init call
                del kwargs["desired_capabilities"]

            kwargs.update(
                {
                    "options": final_options,
                    "keep_alive": True,
                    "file_detector": None,
                }
            )
        elif selenium_version >= version.parse('3.8.0'):
            kwargs.update(
                {
                    "desired_capabilities": final_desired_capabilities,
                    "options": final_options,
                    "keep_alive": True,
                    "file_detector": None,
                }
            )
        elif selenium_version >= version.parse('2.53.0'):
            kwargs.update(
                {
                    "desired_capabilities": final_desired_capabilities,
                    "keep_alive": True,
                    "file_detector": None,
                }
            )
        else:
            kwargs.update(
                {
                    "desired_capabilities": final_desired_capabilities,
                    "keep_alive": True,
                    "file_detector": None,
                }
            )

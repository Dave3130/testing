import json
import time
from datetime import datetime, timezone
from browserstack_sdk.sdk_cli.automation_framework import (
    AutomationFrameworkState,
    HookState,
    AutomationFramework,
    AutomationFrameworkBrowser,
    TrackedContext,
)
from browserstack_sdk.sdk_cli.selenium_framework import SeleniumFramework
from browserstack_sdk.sdk_cli.test_framework import TestFramework, TestFrameworkState, TestHookState, TestFrameworkTest
from browserstack_sdk.sdk_cli.module_base_browserstack_remote import BaseBrowserStackRemoteModule
from typing import Tuple, Dict, Any, List, Union
from bstack_utils.helper import is_bstack_automation
from browserstack_sdk import sdk_pb2 as structs
from bstack_utils.measure import measure
from bstack_utils.constants import *
from typing import Tuple, List, Any

# Associates test cases to webdrivers
class WebDriverTestModule(BaseBrowserStackRemoteModule):
    KEY_DRIVERS = "test_drivers"
    KEY_AUTOMATION_SESSIONS = "automation_sessions"
    KEY_NON_BROWSERSTACK_AUTOMATION_SESSIONS = "non_browserstack_automation_sessions"
    KEY_TEST_SESSIONS = "test_sessions"
    KEY_AUTOMATION_INSTANCE_REFS = "automation_instance_refs"
    KEY_CBT_SESSION_CREATED = "cbt_session_created"
    KEY_CBT_SESSION_NAME = "cbt_session_name"
    KEY_CBT_SESSION_STATUS = "cbt_session_status"

    def __init__(self):
        super().__init__(tracking_key=self.KEY_DRIVERS, frameworks=[SeleniumFramework.NAME])

        if not self.is_enabled():
            return

        TestFramework.set_hook_callback((TestFrameworkState.BEFORE_EACH, TestHookState.POST), self.set_active_drivers)
        TestFramework.set_hook_callback((TestFrameworkState.TEST, TestHookState.PRE), self.on_before_test)
        TestFramework.set_hook_callback((TestFrameworkState.TEST, TestHookState.POST), self.on_after_test)

        # SeleniumFramework.set_hook_callback((AutomationFrameworkState.QUIT, HookState.PRE), self.on_before_driver_quit)

    def is_enabled(self) -> bool:
        return True

    def set_active_drivers(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs,
    ):
        driver_instances = self.active_automation_drivers(instance.context)
        if not driver_instances:
            self.logger.debug(f"set_active_drivers: no driver for hook_info={hook_info}")
        f.set_state(instance, WebDriverTestModule.KEY_AUTOMATION_SESSIONS, driver_instances)
        non_browserstack_driver_instances = self.active_automation_drivers(instance.context, browserstack_drivers=False)
        f.set_state(instance, WebDriverTestModule.KEY_NON_BROWSERSTACK_AUTOMATION_SESSIONS, non_browserstack_driver_instances)

    def on_before_test(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs,
    ):
        self.set_active_drivers(f, instance, hook_info, *args, **kwargs)

        if not f.get_state(instance, WebDriverTestModule.KEY_CBT_SESSION_NAME, False):
            self.__mark_session_name(f,instance,hook_info)

    def on_after_test(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs,
    ):
        self.set_active_drivers(f, instance, hook_info, *args, **kwargs)

        if not f.get_state(instance, WebDriverTestModule.KEY_CBT_SESSION_NAME, False):
            self.__mark_session_name(f, instance, hook_info)

        if not f.get_state(instance, WebDriverTestModule.KEY_CBT_SESSION_STATUS, False):
            self.__mark_session_status(f, instance, hook_info)


    def on_before_driver_quit(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        instance = exec[0]
        if not f.is_instance_browserstack_hub(instance):
            return

        if f.get_state(instance, WebDriverTestModule.KEY_CBT_SESSION_STATUS, False):
            # already done
            return

        # test_instances = list(
        #     filter(
        #         lambda x: TestFramework.has_state(x, TestFramework.KEY_TEST_RESULT_AT),
        #         TestFramework.get_context_instances(instance.context),
        #     )
        # )
        # if not test_instances:
        #     # no result available yet
        #     return

        # # last test instance
        # # TODO: fix this to anyOf(failed) => "failed"
        # result = TestFramework.get_state(test_instances[0], TestFramework.KEY_TEST_RESULT, None)
        # if not result in ("passed", "failed"):
        #     return


        driver.execute_script(
            "browserstack_executor: {}".format(
                json.dumps(
                    {
                        "action": "setSessionStatus",
                        "arguments": {"status": result},
                    }
                )
            )
        )
        f.set_state(instance, WebDriverTestModule.KEY_CBT_SESSION_STATUS, True)

    def active_automation_drivers(self, context: TrackedContext, browserstack_drivers= True):
        if browserstack_drivers:
            driver_instances = self.resolve_drivers(context, reverse=True)
        else:
            driver_instances = self.resolve_non_browserstack_drivers(context, reverse=True)
        return [f for f in driver_instances if f[1].state != AutomationFrameworkState.QUIT]

    @measure(event_name=EVENTS.SDK_AUTOMATE_SESSION_STATUS, stage=STAGE.SINGLE)
    def __mark_session_status(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState],
    ):
        from browserstack_sdk.sdk_cli.cli import cli
        if not cli.config.get("testContextOptions").get("skipSessionStatus"):
            driver_instances = f.get_state(instance, WebDriverTestModule.KEY_AUTOMATION_SESSIONS, [])
            if not driver_instances:
                self.logger.debug(f"set_active_drivers: no driver for hook_info={hook_info}")
                return
            driver = driver_instances[0][0]()

            status = f.get_state(instance, TestFramework.KEY_TEST_RESULT, None)
            if not status:
                self.logger.debug(f"set_active_drivers: no status for test, hook_info={hook_info}")
                return

            test_context_argument = {"status": status.lower()}
            failure_reason = f.get_state(instance, TestFramework.KEY_TEST_FAILURE, None)

            if status.lower() == 'failed' and failure_reason is not None:
                test_context_argument['reason'] = failure_reason[0]['backtrace'][0] if isinstance(failure_reason, list) else str(failure_reason)

            driver.execute_script(
                "browserstack_executor: {}".format(
                    json.dumps(
                        {
                            "action": "setSessionStatus",
                            "arguments": test_context_argument,
                        }
                    )
                )
            )
            f.set_state(instance, WebDriverTestModule.KEY_CBT_SESSION_STATUS, True)

    @measure(event_name=EVENTS.SDK_AUTOMATE_SESSION_NAME, stage=STAGE.SINGLE)
    def __mark_session_name(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState]
    ):
        from browserstack_sdk.sdk_cli.cli import cli
        if not cli.config.get("testContextOptions").get("skipSessionName"):
            test_name = f.get_state(instance, TestFramework.KEY_AUTOMATE_SESSION_NAME, None)
            if not test_name:
                self.logger.debug("on_before_test: missing test name")
                return

            driver_instances = f.get_state(instance, WebDriverTestModule.KEY_AUTOMATION_SESSIONS, [])
            if not driver_instances:
                self.logger.debug(f"set_active_drivers: no status for test, hook_info={hook_info}")
                return

            for driver_weakref, driver_instance in driver_instances:
                if not SeleniumFramework.is_instance_browserstack_hub(driver_instance):
                    continue

                driver = driver_weakref()
                if not driver:
                    continue

                driver.execute_script(
                    "browserstack_executor: {}".format(
                        json.dumps(
                            {
                                "action": "setSessionName",
                                "arguments": {"name": test_name},
                            }
                        )
                    )
                )
            f.set_state(instance, WebDriverTestModule.KEY_CBT_SESSION_NAME, True)

    def mark_o11y_sync(
        self, 
        instance: TestFrameworkTest, 
        f: TestFramework,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs,
    ):
        self.set_active_drivers(f, instance, hook_info, *args, **kwargs)

        driver_instances = [d for d, _ in f.get_state(instance, WebDriverTestModule.KEY_AUTOMATION_SESSIONS, [])]
        if not driver_instances:
            self.logger.debug("on_after_test: no sessions to link")
            return

        if not is_bstack_automation():
            self.logger.debug("on_after_test: not browserstack session")
            return

        for driver_inst in driver_instances:

            driver = driver_inst()

            if not driver:
                continue

            timestamp = int(time.time() * 1000)
            data = "ObservabilitySync:" + str(timestamp)

            driver.execute_script(
                "browserstack_executor: {}".format(
                    json.dumps(
                        {
                            "action": "annotate",
                            "arguments": {
                                "type": "Annotation",
                                "data": data,
                                "level": "debug"
                            }
                        }
                    )
                )
            )

    def get_cbt_event(
        self, 
        instance: TestFrameworkTest, 
        f: TestFramework,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs,
    ):
        self.set_active_drivers(f, instance, hook_info, *args, **kwargs)
        keys = [
            WebDriverTestModule.KEY_AUTOMATION_SESSIONS,
            WebDriverTestModule.KEY_NON_BROWSERSTACK_AUTOMATION_SESSIONS,
        ]

        driver_instances = []
        for key in keys:
            driver_instances.extend(f.get_state(instance, key, []))
        if not driver_instances:
            self.logger.debug("on_after_test: unable to find any sessions to link")
            return

        if f.get_state(instance, WebDriverTestModule.KEY_CBT_SESSION_CREATED, False):
            self.logger.debug("on_after_test: CBT already created")
            return

        self.ensure_bin_session()
        time_start = datetime.now()
        req = structs.TestSessionEventRequest()
        req.bin_session_id = self.bin_session_id
        req.platform_index = TestFramework.get_state(instance, TestFramework.KEY_PLATFORM_INDEX)
        req.test_framework_name = TestFramework.get_state(instance, TestFramework.KEY_TEST_FRAMEWORK_NAME)
        req.test_framework_version = TestFramework.get_state(instance, TestFramework.KEY_TEST_FRAMEWORK_VERSION)
        req.test_framework_state = hook_info[0].name
        req.test_hook_state = hook_info[1].name
        req.test_uuid = TestFramework.get_state(instance, TestFramework.KEY_TEST_UUID)

        #driver_weakfref --> selenium driver instance (used to get driverCaps), driver --> browserstack automation framework driver instance
        for driver_weakref, driver in driver_instances:
            try:
                # Get the actual WebDriver instance from the weakref
                webdriver = driver_weakref()
                if webdriver is None:
                    self.logger.debug("WebDriver instance is None (reference expired)")
                    continue
                
                session = req.automation_sessions.add()
                session.provider = (
                    "browserstack"
                    if SeleniumFramework.get_state(driver, SeleniumFramework.KEY_IS_BROWSERSTACK_HUB, False)
                    else "unknown_grid"
                )
                session.ref = driver.ref()
                session.hub_url = SeleniumFramework.get_state(driver, SeleniumFramework.KEY_HUB_URL, "")
                session.framework_name = driver.framework_name
                session.framework_version = driver.framework_version
                session.framework_session_id = SeleniumFramework.get_state(driver, SeleniumFramework.KEY_FRAMEWORK_SESSION_ID, "")
                
                caps = None
                if hasattr(webdriver, "capabilities"):
                    try:
                        caps = webdriver.capabilities
                        self.logger.debug("Successfully retrieved capabilities directly from driver.capabilities")
                    except Exception as e:
                        self.logger.debug(f"Failed to get capabilities from driver.capabilities: {e}")
                                
                try:
                    serialized_caps = json.dumps(caps).encode("utf-8") if caps else b"{}"
                    req.capabilities = serialized_caps                       
                except Exception as e:
                    self.logger.debug(f"get_cbt_event: failed to send serialize caps for request: {e}")
                    
            except Exception as e:
                self.logger.error(f"Error processing driver item: {str(e)}")

        req.execution_context.hash = str(instance.context.hash)
        req.execution_context.thread_id = str(instance.context.thread_id)
        req.execution_context.process_id = str(instance.context.process_id)

        return req

    def generate_platform_details(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs
    ):
        driver_instances = f.get_state(instance, WebDriverTestModule.KEY_AUTOMATION_SESSIONS, [])
        if not is_bstack_automation() and len(driver_instances) == 0:
            driver_instances = f.get_state(instance, WebDriverTestModule.KEY_NON_BROWSERSTACK_AUTOMATION_SESSIONS, [])
        if not driver_instances:
            self.logger.debug(f"on_before_test: no drivers for hook_info={hook_info} args={args} kwargs={kwargs}")
            return {}

        if len(driver_instances) > 1:
            self.logger.debug(f"on_before_test: {len(driver_instances)} drivers for hook_info={hook_info} args={args} kwargs={kwargs}")
            return {}

        # run scan on the most recent webdriver
        driver_weakref, automation_framework_browser = driver_instances[0]
        driver = driver_weakref()
        if not driver:
            self.logger.debug(f"on_before_test: no driver for hook_info={hook_info} args={args} kwargs={kwargs}")
            return {}

        capabilities = f.get_state(automation_framework_browser, SeleniumFramework.KEY_CAPABILITIES)
        if not capabilities:
            self.logger.debug(f"on_before_test: no capabilities found for hook_info={hook_info} args={args} kwargs={kwargs}")
            return {}
        
        return capabilities.get("alwaysMatch", {})

    def get_automation_driver(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs
    ):
        driver_instances = f.get_state(instance, WebDriverTestModule.KEY_AUTOMATION_SESSIONS, [])
        if not is_bstack_automation() and len(driver_instances) == 0:
            driver_instances = f.get_state(instance, WebDriverTestModule.KEY_NON_BROWSERSTACK_AUTOMATION_SESSIONS, [])
        if not driver_instances:
            self.logger.debug(f"get_automation_driver: no drivers for hook_info={hook_info} args={args} kwargs={kwargs}")
            return

        if len(driver_instances) > 1:
            self.logger.debug(f"get_automation_driver: {len(driver_instances)} drivers for hook_info={hook_info} args={args} kwargs={kwargs}")

        # run scan on the most recent webdriver
        driver_weakref, automation_framework_browser = driver_instances[0]
        driver = driver_weakref()
        if not driver:
            self.logger.debug(f"get_automation_driver: no driver for hook_info={hook_info} args={args} kwargs={kwargs}")
            return

        return driver

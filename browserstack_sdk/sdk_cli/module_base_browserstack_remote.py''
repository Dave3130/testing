from browserstack_sdk.sdk_cli.module_base import BaseModule
from browserstack_sdk.sdk_cli.automation_framework import (
    AutomationFrameworkState,
    HookState,
    AutomationFramework,
    AutomationFrameworkBrowser,
)
from browserstack_sdk.sdk_cli.selenium_framework import SeleniumFramework
from browserstack_sdk.sdk_cli.playwright_framework import PlaywrightFramework

from browserstack_sdk.sdk_cli.tracked_instance import TrackedContext
from typing import Tuple, Dict, Any, List, Callable
from browserstack_sdk.sdk_cli.module_base import BaseModule
import weakref

class BaseBrowserStackRemoteModule(BaseModule):
    tracking_key: str
    frameworks: List[str]
    # WeakReferences to webdriver objects that have been set up for child-modules
    # instance_ref => (WebDriver, AutomationFrameworkBrowser)
    drivers: Dict[str, Tuple[Callable, AutomationFrameworkBrowser]]
    pages: Dict[str, Tuple[Callable, AutomationFrameworkBrowser]]

    def __init__(self, tracking_key: str, frameworks: List[str]):
        super().__init__()
        self.drivers = dict()
        self.pages = dict()

        self.non_browserstack_drivers = dict()

        self.tracking_key = tracking_key
        self.frameworks = frameworks

        PlaywrightFramework.set_hook_callback((AutomationFrameworkState.CREATE, HookState.POST), self.__on_new_page)
        if any(SeleniumFramework.NAME in f.lower().strip() for f in frameworks):
            SeleniumFramework.set_hook_callback(
                (AutomationFrameworkState.EXECUTE, HookState.PRE), self.__on_selenium_init
            )
            SeleniumFramework.set_hook_callback(
                (AutomationFrameworkState.QUIT, HookState.POST), self.__on_selenium_quit
            )

    def __on_new_page(
        self,
        f: PlaywrightFramework,
        browserContext: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        try:
            instance, method_name = exec
            if method_name != "new_page":
                return
            contexts = browserContext.browser.contexts
            if contexts:
                for context in contexts:
                    if context.pages:
                        for page in context.pages:
                            if "about:blank" in page.url:
                                self.logger.debug("Storing the new page instance")
                                self.pages[instance.ref()] = weakref.ref(page), instance
                                AutomationFramework.set_state(instance, self.tracking_key, True)
                                self.logger.debug(f"__on_page_init: instance={instance.ref()}")
        except Exception as e:
            self.logger.debug("Exception in storing new page :",e)

    def __on_selenium_init(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        instance, _ = exec
        if instance.ref() in self.drivers or AutomationFramework.get_state(instance, self.tracking_key, False):
            # instance is already tracked
            return

        if not f.is_browserstack_hub(f.hub_url(driver)):
            self.non_browserstack_drivers[instance.ref()] = weakref.ref(driver), instance
            AutomationFramework.set_state(instance, self.tracking_key, True)
            self.logger.debug(f"__on_selenium_init: non_browserstack_driver instance={instance.ref()}")
            return

        self.drivers[instance.ref()] = weakref.ref(driver), instance
        AutomationFramework.set_state(instance, self.tracking_key, True)
        self.logger.debug(f"__on_selenium_init: instance={instance.ref()}")

    def __on_selenium_quit(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        instance, _ = exec
        if not instance.ref() in self.drivers:
            # this is not a webdriver we track
            return

        self.release_driver(instance)
        self.logger.debug(f"__on_selenium_quit: instance={instance.ref()}")

    def resolve_drivers(self, context: TrackedContext, reverse=True) -> List[Tuple[Callable, AutomationFrameworkBrowser]]:
        matches = []
        if self.pages:
            for data in self.pages.values():
                if data[1].is_same_thread(context):
                    matches.append(data)

        if self.drivers:
            for data in self.drivers.values():
                if (
                    SeleniumFramework.is_instance_browserstack_hub(data[1])
                    and data[1].is_same_thread(context)
                    and getattr(data[0](), "session_id", False)  # webdriver still alive
                ):
                    matches.append(data)
        return sorted(matches, key=lambda d: d[1].created_at, reverse=reverse)
    
    def resolve_non_browserstack_drivers(self, context: TrackedContext, reverse=True) -> List[Tuple[Callable, AutomationFrameworkBrowser]]:
        matches = []

        for data in self.non_browserstack_drivers.values():
            if (
                data[1].is_same_thread(context)
                and getattr(data[0](), "session_id", False)  # webdriver still alive
            ):
                matches.append(data)
        return sorted(matches, key=lambda d: d[1].created_at, reverse=reverse)

    def has_driver(self, instance: AutomationFrameworkBrowser) -> bool:
        return instance and instance.ref() in self.drivers

    def release_driver(self, instance: AutomationFrameworkBrowser) -> bool:
        if self.has_driver(instance):
            self.drivers.pop(instance.ref())
            AutomationFramework.set_state(instance, self.tracking_key, False)
            return True

        return False

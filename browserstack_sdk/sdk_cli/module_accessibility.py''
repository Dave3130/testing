from datetime import datetime
import os
import threading

from browserstack_sdk.sdk_cli.automation_framework import (
    AutomationFrameworkState,
    HookState,
    AutomationFramework,
    AutomationFrameworkBrowser,
)
from browserstack_sdk.sdk_cli.selenium_framework import SeleniumFramework
from browserstack_sdk.sdk_cli.test_framework import TestFramework, TestFrameworkState, TestHookState, TestFrameworkTest
from typing import Tuple, Dict, Any, List, Union
from browserstack_sdk import sdk_pb2 as structs
from browserstack_sdk.sdk_cli.module_base import BaseModule
from browserstack_sdk.sdk_cli.module_webdriver_test import WebDriverTestModule
from browserstack_sdk.sdk_cli.module_playwright_test import PlaywrightTestModule
from browserstack_sdk.sdk_cli.playwright_framework import PlaywrightFramework
from bstack_utils.helper import merge_object
from bstack_utils.measure import measure
from bstack_utils.constants import *
from bstack_utils.performance_tester import PerformanceTester
import grpc
import traceback
import json

# On every test end or *after* a DOM changing command, if the driver is available then we send a A11y perform scan event
# to Chrome Extension through SH driver, by executing a script returned to us by A11y at build start.
class AccessibilityModule(BaseModule):
    LOG_DISABLED_SHOWN = False
    SELENIUM_LIBRARY = "selenium.webdriver"
    SELENIUM_MODULE = "remote.webdriver"

    KEY_INIT = "accessibility_init"

    KEY_IS_SCANNING = "accessibility_is_scanning"
    KEY_DRIVER_HAS_URL = "driver_has_url"

    # framework_name => [ script_name => script_code ]
    scripts: Dict[str, Dict[str, str]]
    # framework_name => [ method_name => [ command_name => script_names[] ] ]
    commands: Dict[str, Dict[str, Dict[str, List[str]]]]

    def __init__(self, module_automation_framework, module_automation_framework_test):
        super().__init__()

        self.scripts = dict()
        self.commands = dict()
        self.accessibility = False
        self.app_accessibility = False
        self.app_accessibility_test_data = dict()

        if not self.is_enabled():
            return

        self.automation_framework_test = module_automation_framework_test

        module_automation_framework.set_hook_callback((AutomationFrameworkState.EXECUTE, HookState.PRE), self.on_before_execute)
        TestFramework.set_hook_callback((TestFrameworkState.TEST, TestHookState.PRE), self.on_before_test)
        TestFramework.set_hook_callback((TestFrameworkState.TEST, TestHookState.POST), self.on_after_test)

    def is_enabled(self) -> bool:
        return True

    def on_before_test(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs,
    ):
        tags = self._extract_tags(instance, args)
        test_framework = f.get_state(instance, TestFramework.KEY_TEST_FRAMEWORK_NAME)
        if self.app_accessibility:
            self.app_accessibility_test_data["test_run_uuid"] = f.get_state(instance, TestFramework.KEY_TEST_UUID)
        if 'pytest-bdd' in instance.test_frameworks:
            platform_index = f.get_state(instance, TestFramework.KEY_PLATFORM_INDEX)
            self.accessibility = self.is_accessibility(tags, self.config['platforms'][platform_index])
        else:
            capabilities = self.automation_framework_test.generate_platform_details(f, instance, hook_info, *args, **kwargs)
            if not capabilities:
                self.logger.debug(f"on_before_test: no capabilities found for hook_info={hook_info} args={args} kwargs={kwargs}")
                return

            self.accessibility = self.is_accessibility(tags, capabilities)

        if self.automation_framework_test.pages and self.automation_framework_test.pages.values():
            pages_list = list(self.automation_framework_test.pages.values())

            if pages_list and isinstance(pages_list[0], (list, tuple)) and pages_list[0]:
                page_instance = pages_list[0][0]

                if callable(page_instance):
                    page = page_instance()

                    def get_results():
                        self.get_accessibility_results(page, "playwright")

                    def get_result_summary():
                        self.get_accessibility_results_summary(page, "playwright")

                    setattr(page, "getAccessibilityResults", get_results)
                    setattr(page, "getAccessibilityResultSummary", get_result_summary)

        self.logger.debug(f"should run accessibility value={self.accessibility}")

    def on_before_execute(
        self,
        f: SeleniumFramework,
        driver: object,
        exec: Tuple[AutomationFrameworkBrowser, str],
        hook_info: Tuple[AutomationFrameworkState, HookState],
        result: Any,
        *args,
        **kwargs,
    ):
        try:
            time_start = datetime.now()
            self.init_accessibility_config(f, exec, *args, **kwargs)

            instance, method_name = exec
            instance.add_benchmark("a11y:init_accessibility_config", datetime.now() - time_start)

            if (
                not f.is_execute_request(method_name)
                or f.is_browserstack_script_command(method_name, *args)
                or f.is_accessibility_script_command(method_name, *args)
            ):
                return

            if not f.get_state(instance, AccessibilityModule.KEY_INIT, False):
                # we only process webdrivers we set caps for
                if not AccessibilityModule.LOG_DISABLED_SHOWN:
                    self.logger.warning(f"[platform_index={f.platform_index}] a11y capabilities have not been set for this session")
                    AccessibilityModule.LOG_DISABLED_SHOWN = True
                return

            # for a11y commands we received from the server and pre-stored in maps
            framework_scripts = self.scripts.get(f.framework_name, {})
            if not framework_scripts:
                # noisy
                platform_index = f.get_state(instance, SeleniumFramework.KEY_PLATFORM_INDEX, 0)
                self.logger.debug(f"no a11y scripts for platform_index={platform_index} framework_name={f.framework_name}")
                return

            command_name = f.parse_command_name(*args)
            if not command_name:
                self.logger.debug(f"missing command_name for framework_name={f.framework_name} method_name={method_name}")
                return

            url_set = f.get_state(instance, AccessibilityModule.KEY_DRIVER_HAS_URL, False)
            if command_name == "get" and not url_set:
                # some URL has just been loaded by the user
                f.set_state(instance, AccessibilityModule.KEY_DRIVER_HAS_URL, True)
                url_set = True

            if not url_set and not self.app_accessibility:
                self.logger.debug(f"no URL loaded framework_name={f.framework_name} command_name={command_name}")
                return

            scripts_to_run = self.commands.get(f.framework_name, {}).get(method_name, {}).get(command_name, [])
            if not scripts_to_run:
                self.logger.debug(f"no a11y scripts for framework_name={f.framework_name} command_name={command_name}")
                return

            self.logger.info(f"running {len(scripts_to_run)} scripts framework_name={f.framework_name} command_name={command_name}")
            scripts = [(s, framework_scripts[s]) for s in scripts_to_run if s in framework_scripts]

            for script_name, script_code in scripts:
                try:
                    time_start = datetime.now()
                    if script_name == "scan":
                        result = self.perform_scan(driver, method=command_name, framework_name=f.framework_name)
                    instance.add_benchmark("a11y:" + script_name, datetime.now() - time_start)

                    if isinstance(result, dict) and not result.get("success", True):
                        # scripts are interdependent, scan -> saveResults -> getResults -> getResultsSummary
                        # so we fail remaining scripts if any one script fails
                        self.logger.warning(f"skip executing remaining scripts: {result}")
                        break
                except Exception as e:
                    self.logger.error(f"error executing script={script_name} error={e}")
                    # traceback.print_exc()
        except Exception as e:
            self.logger.error(f"on_before_execute error={e}")

    def on_after_test(
        self,
        f: TestFramework,
        instance: TestFrameworkTest,
        hook_info: Tuple[TestFrameworkState, TestHookState],
        *args,
        **kwargs,
    ):
        tags = self._extract_tags(instance, args)
        capabilities = self.automation_framework_test.generate_platform_details(f, instance, hook_info, *args, **kwargs)
        self.accessibility = self.is_accessibility(tags, capabilities)
        # Above code in case driver was not initialised in before step
        if not self.accessibility:
            self.logger.debug("on_after_test: a11y not enabled")
            return

        driver = self.automation_framework_test.get_automation_driver(f, instance, hook_info, *args, **kwargs)
        test_name = f.get_state(instance, TestFramework.KEY_TEST_NAME)
        if not test_name:
            self.logger.debug("on_after_test: missing test name")
            return

        test_uuid = f.get_state(instance, TestFramework.KEY_TEST_UUID)
        if not test_uuid:
            self.logger.debug("on_after_test: missing test uuid")
            return

        if isinstance(self.automation_framework_test, PlaywrightTestModule):
            framework_name = 'playwright'
        else:
            framework_name = 'selenium'
        self.stop_test_capture(driver, test_name, framework_name, test_uuid)

    def perform_scan(self, driver: object, method: Union[None, str], framework_name: str):
        random_label = PerformanceTester.mark_start(EVENTS.SDK_A11Y_PERFORM_SCAN.value)
        if not self.accessibility:
            self.logger.debug("perform_scan: a11y not enabled framework_name={framework_name} ")
            return
        time_start = datetime.now()
        script_code = self.scripts.get(framework_name, {}).get("scan", None)
        if not script_code:
            self.logger.debug(f"perform_scan: missing 'scan' script for framework_name={framework_name} ")
            return

        if self.app_accessibility:
            arg = dict()
            arg["method"] = method if method else ""
            arg["thTestRunUuid"] = self.app_accessibility_test_data["test_run_uuid"]
            arg["thBuildUuid"] = self.app_accessibility_test_data["testhub_build_uuid"]
            arg["authHeader"] = self.app_accessibility_test_data["accessibilityToken"]
            arg["thJwtToken"] = self.app_accessibility_test_data["th_jwt_token"]
            arg["scanTimestamp"] = str(int(datetime.now().timestamp() * 1000))
            formatted_script = script_code % json.dumps(arg)
            driver.execute_script(formatted_script)
            return

        instance = AutomationFramework.get_tracked_instance(driver)
        if instance:
            if not AutomationFramework.get_state(instance, AccessibilityModule.KEY_IS_SCANNING, False):
                AutomationFramework.set_state(instance, AccessibilityModule.KEY_IS_SCANNING, True)
            else:
                self.logger.info(f"perform_scan: already in progress framework_name={framework_name} method={method}")
                return

        self.logger.info(f"perform_scan: framework_name={framework_name} method={method}")
        if framework_name == 'playwright':
            result = self.automation_framework_test.a11y_script_execute(driver, script_code)
        else:
            result = driver.execute_async_script(script_code, {"method": method if method else ""})

        PerformanceTester.end(EVENTS.SDK_A11Y_PERFORM_SCAN.value, random_label+":start", random_label+":end", True, None, command=method)
        if instance:
            AutomationFramework.set_state(instance, AccessibilityModule.KEY_IS_SCANNING, False)
            instance.add_benchmark("a11y:perform_scan", datetime.now() - time_start)
        return result

        def get_app_accessibility_result(self, driver: object, framework_name, result_type: str):
            self.ensure_bin_session()
            req = structs.AccessibilityResultRequest()
            req.bin_session_id = self.bin_session_id
            req.test_run_id = self.app_accessibility_test_data["test_run_uuid"]
            req.result_type = result_type
            req.session_id = self.bin_session_id
            try:
                r = self.cli_service.AccessibilityResult(req)
                if not r.success:
                    self.logger.debug(f"received from server: {r}")
                else:
                    response_dict = json.loads(r.result_response.decode('utf-8'))
                    if result_type == 'getResults':
                        return response_dict.get("data", [])
                    else:
                        return response_dict.get("data", {})
            except grpc.RpcError as e:
                self.logger.error(f"rpc-error while fetching get_app_accessibility_result from cli: {e}")

    @measure(event_name=EVENTS.SDK_A11Y_GET_RESULTS, stage=STAGE.SINGLE)
    def get_accessibility_results(self, driver: object, framework_name):
        if not self.accessibility:
            self.logger.debug("get_accessibility_results: a11y not enabled")
            return
        if self.app_accessibility:
            self.logger.debug('Performing scan for app accessibility')
            self.perform_scan(driver, method=None, framework_name=framework_name)
            return self.get_app_accessibility_result(driver, framework_name, "getResults")
        script_code = self.scripts.get(framework_name, {}).get("getResults", None)
        if not script_code:
            self.logger.debug(f"missing 'getResults' script for framework_name={framework_name}")
            return

        self.perform_scan(driver, method=None, framework_name=framework_name)
        time_start = datetime.now()

        if framework_name == 'playwright':
            result = self.automation_framework_test.a11y_script_execute(driver, script_code)
        else:
            result = driver.execute_async_script(script_code)

        instance = AutomationFramework.get_tracked_instance(driver)
        if instance:
            instance.add_benchmark("a11y:get_accessibility_results", datetime.now() - time_start)
        return result

    @measure(event_name=EVENTS.SDK_A11Y_GET_RESULTS_SUMMARY, stage=STAGE.SINGLE)
    def get_accessibility_results_summary(self, driver: object, framework_name):
        if not self.accessibility:
            self.logger.debug("get_accessibility_results_summary: a11y not enabled")
            return
        if self.app_accessibility:
            self.perform_scan(driver, method=None, framework_name=framework_name)
            return self.get_app_accessibility_result(driver, framework_name, 'getResultsSummary')
        script_code = self.scripts.get(framework_name, {}).get("getResultsSummary", None)
        if not script_code:
            self.logger.debug(f"missing 'getResultsSummary' script for framework_name={framework_name}")
            return

        self.perform_scan(driver, method=None, framework_name=framework_name)
        time_start = datetime.now()

        if framework_name == 'playwright':
            result = self.automation_framework_test.a11y_script_execute(driver, script_code)
        else:
            result = driver.execute_async_script(script_code)

        instance = AutomationFramework.get_tracked_instance(driver)
        if instance:
            instance.add_benchmark("a11y:get_accessibility_results_summary", datetime.now() - time_start)
        return result

    @measure(event_name=EVENTS.SDK_ACCESSIBILITY_CONFIG, stage=STAGE.SINGLE)
    def accessibility_config(
        self,
        platform_index: int,
        framework_name: str,
        framework_version: str,
        hub_url: str,
    ):
        self.ensure_bin_session()
        req = structs.AccessibilityConfigRequest()
        req.bin_session_id = self.bin_session_id
        req.platform_index = platform_index
        req.framework_name = framework_name
        req.framework_version = framework_version
        req.hub_url = hub_url

        try:
            r = self.cli_service.AccessibilityConfig(req)
            if not r.success:
                self.logger.debug(f"received from server: {r}")
            else:
                self.load_config(framework_name, r)
            return r
        except grpc.RpcError as e:
            self.logger.error(f"rpc-error: {e}")
            traceback.print_exc()
            raise e

    def load_config(self, framework_name: str, result: structs.AccessibilityConfigResponse) -> bool:
        if not result.success or not result.accessibility.success:
            self.logger.debug("load_config: a11y not found")
            return False
        if result.accessibility.is_app_accessibility:
            self.app_accessibility = result.accessibility.is_app_accessibility
        if result.testhub.build_hashed_id:
            self.app_accessibility_test_data["testhub_build_uuid"] = result.testhub.build_hashed_id
        if result.testhub.jwt:
            self.app_accessibility_test_data["th_jwt_token"] = result.testhub.jwt
        if result.accessibility.options:
            options = result.accessibility.options
            if options.capabilities:
                for caps in options.capabilities:
                    self.app_accessibility_test_data[caps.name] = caps.value
            if options.scripts:
                self.scripts[framework_name] = {row.name: row.command for row in options.scripts}

            if options.commands_to_wrap and options.commands_to_wrap.commands:
                scripts_to_run = [s for s in options.commands_to_wrap.scripts_to_run]
                if not scripts_to_run:
                    return False

                framework_commands = dict()
                for command in options.commands_to_wrap.commands:
                    if command.library == self.SELENIUM_LIBRARY and command.module == self.SELENIUM_MODULE:
                        if command.method and not command.method in framework_commands:
                            framework_commands[command.method] = dict()

                        if command.name and not command.name in framework_commands[command.method]:
                            framework_commands[command.method][command.name] = list()

                        framework_commands[command.method][command.name].extend(scripts_to_run)

                self.commands[framework_name] = framework_commands

        return bool(self.commands.get(framework_name, None))

    def init_accessibility_config(
        self,
        f: SeleniumFramework,
        exec: Tuple[AutomationFrameworkBrowser, str],
        *args,
        **kwargs,
    ):
        instance, method_name = exec
        if isinstance(self.automation_framework_test, PlaywrightTestModule) and method_name != 'connect':
            return

        if AutomationFramework.has_state(instance, AccessibilityModule.KEY_INIT):
            # instance has been configured for Accessibility already
            return

        if f.is_new_session_command(method_name, *args):
            # attach accessibility capabilities to new session on BrowserStack
            is_commands_configured = False
            desired_capabilities = f.instance_capabilities(instance)

            if isinstance(desired_capabilities, dict):
                hub_url = f.instance_hub_url(instance)
                platform_index = f.get_state(instance, SeleniumFramework.KEY_PLATFORM_INDEX, 0)
                grpc_time_start = datetime.now()
                r = self.accessibility_config(platform_index, f.framework_name, f.framework_version, hub_url)
                instance.add_benchmark("grpc:accessibility_config", datetime.now() - grpc_time_start)
                is_commands_configured = r.success
            else:
                self.logger.error(f"missing desired capabilities={desired_capabilities}")

            f.set_state(instance, AccessibilityModule.KEY_INIT, is_commands_configured)

    def is_enabled_testcase(self, test_tags):
        accessibility_config = self.config.get('accessibilityOptions')
        if not accessibility_config:
            return True
        try:
            include_tags = accessibility_config['includeTagsInTestingScope'] if 'includeTagsInTestingScope' in accessibility_config and isinstance(accessibility_config['includeTagsInTestingScope'], list) else []
            exclude_tags = accessibility_config['excludeTagsInTestingScope'] if 'excludeTagsInTestingScope' in accessibility_config and isinstance(accessibility_config['excludeTagsInTestingScope'], list) else []

            excluded = any(tag in exclude_tags for tag in test_tags)
            included = len(include_tags) == 0 or any(tag in include_tags for tag in test_tags)

            return not excluded and included
        except Exception as error:
            self.logger.debug("Error while validating test case for accessibility before scanning. Error : " + str(error))
        return False

    def is_platform_supported(self, caps):
        try:
            if self.app_accessibility:
                platform_name = caps.get("platformName")
                if platform_name is not None and str(platform_name).lower() == "android":
                    platform_version = caps.get("appium:platformVersion") or caps.get("platformVersion")
                    if platform_version is not None and int(platform_version) < 11:
                        self.logger.warning(f"Accessibility Automation will run only on Android 11 and above. Current platform version ={platform_version}")
                        return False
                return True
            device_name = caps.get('bstack:options', {}).get('deviceName', caps.get('device', ''))

            if device_name:
                self.logger.warning("Accessibility Automation will run only on Desktop browsers.")
                return False

            browser = caps.get('browserName', '').lower()
            if browser != 'chrome':
                self.logger.warning("Accessibility Automation will run only on Chrome browsers.")
                return False

            min_a11y_supported_chrome_version = MINIMUM_ACCESSIBILITY_SUPPORTED_CHROME_VERSION
            if not self.config.get('browserstackAutomation') or self.config.get('turboscale'):
                min_a11y_supported_chrome_version = MINIMUM_NON_BSTACK_INFRA_A11Y_SUPPORTED_CHROME_VERSION
            browser_version = caps.get('browserVersion')
            if not browser_version:
                browser_version = caps.get('bstack:options', {}).get('browserVersion', '')
            if browser_version and browser_version != 'latest' and int(browser_version.split('.')[0]) <= min_a11y_supported_chrome_version:
                self.logger.warning(f"Accessibility Automation will run only on Chrome browser version greater than {min_a11y_supported_chrome_version}.")
                return False

            chromeOptions = caps.get('bstack:options', {}).get('chromeOptions')
            if not chromeOptions:
                chromeOptions = caps.get('goog:chromeOptions', {})
            if chromeOptions and '--headless' in chromeOptions.get('args', []):
                self.logger.warning("Accessibility Automation will not run on legacy headless mode. Switch to new headless mode or avoid using headless mode.")
                return False

            return True
        except Exception as error:
            self.logger.debug("Exception in validate a11y support :" + str(error))
            return False

    def load_driver_execute_params(self, test_uuid: str, result: structs.FetchDriverExecuteParamsEventResponse):
        data_for_extension = {
            'thTestRunUuid': test_uuid,
        }
        a11y_execute_params = {}
        if result.success:
            a11y_execute_params = json.loads(result.accessibility_execute_params)

        return merge_object(data_for_extension, a11y_execute_params)

    def stop_test_capture(self, driver: object, name: str, framework_name: str, test_uuid: str):
        random_label = None

        try:
            self.ensure_bin_session()
            req = structs.FetchDriverExecuteParamsEventRequest()
            req.bin_session_id = self.bin_session_id
            req.product = "accessibility"
            req.script_name = "saveResults"

            r = self.cli_service.FetchDriverExecuteParamsEvent(req)
            if not r.success:
                self.logger.debug(f"received driver execute params from server: {r.error}")
            else:
                data_for_extension = self.load_driver_execute_params(test_uuid, r)
                script_code = r.script

            # Perform scan before saving results
            self.logger.debug('Performing scan before saving results' + str(data_for_extension))
            # Not calling perform_scan method in init.py to avoid circular dependency
            self.perform_scan(driver, name, framework_name=framework_name)
            if not script_code:
                self.logger.debug(f"perform_scan: missing 'saveResults' script for framework_name={framework_name} ")
                return
            random_label = PerformanceTester.mark_start(EVENTS.SDK_A11Y_SAVE_RESULTS.value)
            self.perform_save_results(driver, script_code, data_for_extension, framework_name)
            self.logger.info("Accessibility testing for this test case has ended.")
            PerformanceTester.end(EVENTS.SDK_A11Y_SAVE_RESULTS.value, random_label+":start", random_label+":end", True, None, command='saveResults',test_name=name)
        except Exception as er:
            self.logger.error("Accessibility results could not be processed for the test case: " + "str(path)" + " Error :" + str(er))
            PerformanceTester.end(EVENTS.SDK_A11Y_SAVE_RESULTS.value, random_label+":start", random_label+":end", False, er, command='saveResults',test_name=name)

    def perform_save_results(self, driver, script_code, data_for_extension, framework_name):
        if framework_name == 'playwright':
            self.automation_framework_test.a11y_script_execute(driver, script_code, data_for_extension)
        else:
            self.logger.debug(driver.execute_async_script(script_code, data_for_extension))

    def _extract_tags(self, instance: TestFrameworkTest, args: Tuple) -> list:
        """Extract tags based on the test framework."""
        if 'pytest-bdd' in instance.test_frameworks:
            return args[2].tags if hasattr(args[2], 'tags') else []
        if hasattr(args[0], 'own_markers'):
            return [marker.name for marker in args[0].own_markers]
        return []

    def is_accessibility(self, tags, capabilities):
        return self.is_enabled_testcase(tags) and self.is_platform_supported(capabilities)

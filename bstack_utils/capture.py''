import builtins
import logging

class CaptureLogs:
    def __init__(self, handler):
        self._orig_print = builtins.print
        self.handler = handler
        self._started = False

        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

        # Store original logging methods
        self._orig_log_methods = {
            level: getattr(self.logger, level)
            for level in ['info', 'debug', 'warning', 'error']
        }

    def start(self):
        if self._started:
            return
        self._started = True

        builtins.print = self._custom_print
        self._patch_logging_methods()

    def _custom_print(self, *args, **kwargs):
        self._orig_print(*args, **kwargs)
        message = ' '.join(map(str, args)) + '\n'
        self._log_message('INFO', message)

    # We were utilising "sys.stdout.write" and "sys.stdout.write", 
    # which resulted in logging all kinds of logs to O11y, 
    # including SDK logs.
    # 
    # This new approach will streamline LogEvents for other frameworks 
    # by sending only the logs from the print and logging methods to O11y.
    def _log_message(self, level, msg, *args, **kwargs):
        if self.handler:
            self.handler({'level': level, 'message': msg})

    def _patch_logging_methods(self):
        for level, orig_method in self._orig_log_methods.items():
            setattr(logging, level, self._create_log_wrapper(level, orig_method))

    def _create_log_wrapper(self, level, orig_method):
        def wrapper(msg, *args, **kwargs):
            orig_method(msg, *args, **kwargs)
            self._log_message(level.upper(), msg)
        return wrapper

    def reset(self):
        if not self._started:
            return

        self._started = False
        builtins.print = self._orig_print

        # Restore original logging methods
        for level, orig_method in self._orig_log_methods.items():
            setattr(logging, level, orig_method)

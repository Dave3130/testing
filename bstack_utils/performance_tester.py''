from filelock import FileLock
import json
import os
import time
import uuid
import logging
from typing import Dict, List, Optional

from bstack_utils.logger_utils import get_logger

logger = get_logger(__name__)
MARKS: Dict[str, float] = {}
KEY_METRICS: List = []
MAX_LOCK_ATTEMPT = 5
FILE_PATH = os.path.join(os.getcwd(), 'log', 'key-metrics.json')
logging.getLogger('filelock').setLevel(logging.WARNING)
lock = FileLock(FILE_PATH+".lock")

class KeyMetrics:
    duration: float
    name: str
    startTime: float
    worker: int
    status: bool
    failure: str
    details: Optional[str]
    entryType: str
    platform: Optional[int]
    command: Optional[str]
    hookType: Optional[str]
    cli: Optional[bool]

    def __init__(self, duration: float, name: str, start_time: float, worker_id: int, status: bool, failure: str, details: Optional[str] = None, platform: Optional[int] = None, command: Optional[str] = None, test_name: Optional[str] = None, hook_type: Optional[str] = None, cli: Optional[bool] = False) -> None:
        self.duration = duration
        self.name = name
        self.startTime = start_time
        self.worker = worker_id
        self.status = status
        self.failure = failure
        self.details = details
        self.entryType = "measure"
        self.platform = platform
        self.command = command
        self.testName = test_name
        self.hookType = hook_type
        self.cli = cli

class PerformanceTester:
    global MARKS

    @staticmethod
    def mark_start(key: str):
        random_label = PerformanceTester.get_randomized_label(key)
        PerformanceTester.mark(random_label+":start")
        return random_label
    
    @staticmethod
    def mark(key: str) -> None:
        try:
            MARKS[key] = time.time_ns() / 1000000
        except Exception as e:
            logger.debug("Error: {}".format(e))

    @staticmethod
    def end(label: str, start: str, end: str, status: bool, failure: Optional[str] = None, hook_type: Optional[str] = None, details: Optional[str] = None, command: Optional[str] = None, test_name: Optional[str] = None) -> None:
        try:
            PerformanceTester.mark(end)
            PerformanceTester.measure(label, start, end, status, failure, hook_type, details, command, test_name)
        except Exception as e:
            logger.debug("Error in key metrics: {}".format(e))


    @staticmethod
    def measure(label: str, start: str, end: str, status: bool, failure: Optional[str], hook_type: Optional[str] = None, details: Optional[str] = None, command: Optional[str] = None, test_name: Optional[str] = None) -> None:
        try:
            if start not in MARKS or end not in MARKS:
                logger.debug("Error in start key with value {} or end key with value {}".format(start,end))
                return
            duration: float = MARKS[end] - MARKS[start]
            is_cli = os.environ.get("BROWSERSTACK_BINARY_IS_RUNNING", "false").lower() == "true"
            key_metric: KeyMetrics = KeyMetrics(duration, label, MARKS[start], os.getpid(), status, failure, details, os.environ.get("BROWSERSTACK_PLATFORM_INDEX", 0), command, test_name, hook_type, is_cli)
            del MARKS[start]
            del MARKS[end]
            PerformanceTester.append_data_to_key_metrics(key_metric)
        except Exception as e:
            logger.debug("Error while measuring key metrics: {}".format(e))


    @staticmethod
    def append_data_to_key_metrics(key_metric):
        os.makedirs(os.path.dirname(FILE_PATH)) if not os.path.exists(os.path.dirname(FILE_PATH)) else None
        PerformanceTester.verify_lock()
        try:
            with lock:
                with open(FILE_PATH, "r+", encoding="utf-8") as file:
                    try:
                        data = json.load(file)
                    except json.JSONDecodeError:
                        data = []

                    data.append(key_metric.__dict__)
                    file.seek(0)
                    file.truncate()
                    json.dump(data, file, indent=4)
        except FileNotFoundError as Fnf:
            logger.debug("File not found {}".format(Fnf))
            with lock:
                with open(FILE_PATH, "w", encoding="utf-8") as file:
                    data = [key_metric.__dict__]
                    json.dump(data, file, indent=4)
        except Exception as e:
            logger.debug("Exception while key metrics append {}".format(str(e)))
        finally:
            if os.path.exists(FILE_PATH+".lock"):
                os.remove(FILE_PATH+".lock")

    @staticmethod
    def verify_lock():
        attempt = 0
        while (attempt < MAX_LOCK_ATTEMPT):
            attempt += 1
            if os.path.exists(FILE_PATH+".lock"):
                time.sleep(0.5)
            else:
                break

    @staticmethod
    def get_randomized_label(label: str) -> str:
        try:
            return "{}:{}".format(label,str(uuid.uuid4().hex)[:6])
        except Exception as e:
            logger.debug("Error: {}".format(e))


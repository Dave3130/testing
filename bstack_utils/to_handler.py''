import os
import threading

from bstack_utils.helper import is_true
from bstack_utils.constants import O11Y_SUPPORTED_FRAMEWORKS, EVENTS, STAGE
from bstack_utils.logger_utils import get_logger

logger = get_logger(__name__)

class TOHandler:
    request_queue = None

    @classmethod
    def print_build_link(cls):
        if cls.on() and os.getenv("BROWSERSTACK_TESTHUB_UUID"):
            logger.info(
                'Visit https://automation.browserstack.com/builds/{} to view build report, insights, and many more debugging information all at one place!\n'.format(os.getenv("BROWSERSTACK_TESTHUB_UUID")))

    @classmethod
    def on(cls):
        if os.environ.get('BROWSERSTACK_TESTHUB_JWT', None) is None or os.environ['BROWSERSTACK_TESTHUB_JWT'] == "null":
            return False

        return True

    @classmethod
    def enabled_in_config(cls, bs_config, framework=""):
        default_val = False
        for fw in O11Y_SUPPORTED_FRAMEWORKS:
            if fw in framework:
                default_val = True
        return is_true(bs_config.get('testObservability', default_val))
    
    @classmethod
    def supported_framework(cls, framework):
        return framework in O11Y_SUPPORTED_FRAMEWORKS

    @classmethod
    def is_observability_enabled(cls, bs_config, framework):
        return cls.enabled_in_config(bs_config, framework) is True and cls.supported_framework(framework)

    @staticmethod
    def current_hook_uuid():
        return getattr(threading.current_thread(), 'current_hook_uuid', None)

    @staticmethod
    def get_active_test_or_hook():
        if getattr(threading.current_thread(), 'current_test_uuid', None):
            return {
                'type': 'test',
                'test_run_uuid': getattr(threading.current_thread(), 'current_test_uuid', None)
            }

        if getattr(threading.current_thread(), 'current_hook_uuid', None):
            return {
                'type': 'hook',
                'hook_run_uuid': getattr(threading.current_thread(), 'current_hook_uuid', None)
            }

        return None

    @staticmethod
    def need_to(func):
        # TODO: Figure out a way to use this decorator with pytest hooks which uses signature inspection.
        # https://stackoverflow.com/q/65734222/8852419
        # https://stackoverflow.com/a/72242606/8852419
        def wrap(*args, **kwargs):
            if TOHandler.on():
                return func(*args, **kwargs)
            return

        return wrap

    @staticmethod
    def get_scope_of_test(test, hook_name=None):
        ele = test.parent
        if hook_name in ['setup_class', 'teardown_class', 'setup_module', 'teardown_module']:
            ele = test
        scope = []
        while ele is not None:
            scope.append(ele.name)
            ele = ele.parent

        scope.reverse()
        return scope[2:]

    @staticmethod
    def hook_name_from_type(hook_type):
        if hook_type == "BEFORE_EACH":
            return "Setup hook"
        elif hook_type == "AFTER_EACH":
            return "Teardown hook"

    @staticmethod
    def get_pytest_rerun_specs(spec_files):
        try:
            if not TOHandler.on():
                return spec_files
            if os.environ.get("BROWSERSTACK_RERUN", None) == "true":
                tests = os.environ.get("BROWSERSTACK_RERUN_TESTS", None)

                if tests is None or tests == "null":
                    return spec_files
                spec_files = tests.split(',')
                return spec_files
        except Exception as exc:
            # self.logger.error(str(exc))
            logger.debug(f"Exception in rerun handler: {str(exc)}")
        return spec_files

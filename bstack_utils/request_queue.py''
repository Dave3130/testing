import threading
import logging
logger = logging.getLogger(__name__)

BATCH_SIZE = 1000
BATCH_INTERVAL = 2


class RequestQueue:
    def __init__(self, handler, batch_length=BATCH_SIZE, batch_interval=BATCH_INTERVAL):
        self.queue = []
        self.handler = handler
        self.batch_length = batch_length
        self.batch_interval = batch_interval
        self.lock = threading.Lock()
        self.timer = None
        self.stop_event = None

    def start(self):
        if not (self.timer and self.timer.is_alive()):
            self.start_timer()

    def start_timer(self):
        self.stop_event = threading.Event()

        def timer_thread():
            self.stop_event.wait(self.batch_interval)
            if not self.stop_event.is_set():
                self.call_handler()

        self.timer = threading.Thread(target=timer_thread, daemon=True)
        self.timer.start()


    def stop_timer(self):
        try:
            if self.stop_event and not self.stop_event.is_set():
                self.stop_event.set()
            if self.timer and self.timer.is_alive() and self.timer != threading.current_thread():
                self.timer.join()
        except Exception as e:
            logger.debug('[stop_timer] Exception: ' + (str(e) or "Exception could not be converted to string"))
        finally:
            self.timer = None


    def restart_timer(self):
        if self.timer:
            self.stop_timer()
        self.start_timer()

    def add(self, event):
        with self.lock:
            self.queue.append(event)
            if len(self.queue) >= self.batch_length:
                threading.Thread(target=self.call_handler).start()

    def call_handler(self, source = ''):
        with self.lock:
            if not self.queue:
                self.restart_timer()
                return
            data = self.queue[:self.batch_length]
            del self.queue[:self.batch_length]
        self.handler(data)
        if source != 'shutdown':
            self.restart_timer()

    def shutdown(self):
        self.stop_timer()
        while self.queue:
            self.call_handler(source='shutdown')

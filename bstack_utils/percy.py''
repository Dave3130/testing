import os
import re
import sys
import json
import time
import shutil
import tempfile
import requests
import subprocess
from threading import Thread
from os.path import expanduser
from bstack_utils.constants import *
from requests.auth import HTTPBasicAuth
from bstack_utils.helper import fire_request
from bstack_utils.measure import measure

from bstack_utils.api_utils import bstack_api_url


class Percy:
  working_dir = os.getcwd()
  is_app_automate = False
  config = {}
  binary_name = ''
  binary_path = ''
  percy_log_path = ''
  percy_session = False
  percy_start_proc = None
  percy_options = {}
  percy_start_wait_count = 300
  is_percy_running = False
  logger = None
  setup_failed = False
  is_auto_enable = False
  percy_build_id = None
  hostType = ''
  browser_rank = {
    'chrome' : 1,
    'firefox' : 2,
    'edge' : 3,
    'safari' : 4
  }

  def __init__(self) -> None: pass

  def get_percy_uri(self):
    httpPath = ''
    hostOs = sys.platform
    binaryName = 'percy'
    if re.match("darwin|mac os", hostOs) != None:
      httpPath = PERCY_BINARY_DOWNLOAD_URI + "/percy-osx.zip"
      self.hostType = 'mac'
    elif re.match("mswin|msys|mingw|cygwin|bccwin|wince|emc|win32", hostOs) != None:
      httpPath = PERCY_BINARY_DOWNLOAD_URI + "/percy-win.zip"
      binaryName = "percy.exe"
      self.hostType = 'win'
    else:
      httpPath = PERCY_BINARY_DOWNLOAD_URI + "/percy-linux.zip"
      self.hostType = 'linux'
    return httpPath, binaryName

  def get_available_dir(self):
    try:
      ordered_paths = [os.path.join(expanduser("~"), '.browserstack'), self.working_dir, tempfile.gettempdir()]
      for path in ordered_paths:
        if(self.make_path(path)):
          return path
      raise "Unable to download percy binary"
    except Exception as e:
      self.logger.error("Failed to find available path for percy download, Exception - {}".format(e))
  
  def make_path(self, path):
    try:
      if not os.path.exists(path):
        os.makedirs(path)
      return True
    except:
      return False

  def get_etag_path(self, percy_dir):
    return os.path.join(percy_dir, self.binary_name + ".etag")

  def save_etag(self, percy_dir, etag):
    if not etag: return

    try:
      etag_path = self.get_etag_path(percy_dir)
      with open(etag_path, "w") as f:
        f.write(etag)
        self.logger.debug("Saved new ETag for percy")
    except Exception as e:
      self.logger.error("Unable to save the etag, error: {}".format(e))

  def load_etag(self, percy_dir):
    try:
      etag_path = self.get_etag_path(percy_dir)
      if os.path.exists(etag_path):
        with open(etag_path, "r") as f:
          etag = f.read().strip()
          return etag if etag else None
    except Exception as e:
      self.logger.error("Failed loading ETag, error: {}".format(e))

  def validate_etag(self, percy_dir, httpPath):
    curr_etag = self.load_etag(percy_dir)
    if curr_etag:
      try:
        need_upgrade = self.check_for_upgrade(curr_etag, httpPath)
        if not need_upgrade:
          self.logger.debug("Percy binary is up to date (ETag unchanged)")
          return True
        self.logger.debug("New Percy binary version available, downloading update")
        return False
      except Exception as e:
        self.logger.warn("Failed to check for binary updates, using existing binary: {}".format(e))
    return False

  def check_for_upgrade(self, curr_etag, httpPath):
    try:
      headers = {
        "If-None-Match": curr_etag
      }
      response = fire_request('GET', httpPath, {}, {"headers": headers})
      if response.status_code == 304:
        return False
      return True
    except Exception as e:
      raise("Error checking for Percy binary updates: {}".format(e))


  @measure(event_name=EVENTS.SDK_PERCY_DOWNLOAD, stage=STAGE.SINGLE)
  def download_percy_binary(self, httpPath, binaryName):
    try:
      percy_binary_dir = self.get_available_dir()
      binary_zip_path = os.path.join(percy_binary_dir, 'percy.zip')
      percy_binary_path = os.path.join(percy_binary_dir, binaryName)

      if self.validate_etag(percy_binary_dir, httpPath): # if true, means etag is similar to latest version available (response 304)

        # if unzipped percy bin exist
        if os.path.exists(percy_binary_path):
          self.logger.info("Percy binary found in {}, skipping download".format(percy_binary_path))
          return percy_binary_path

        # if downloaded zip already exist
        if os.path.exists(binary_zip_path):
          self.logger.info("Percy zip found in {}, unzipping".format(binary_zip_path))
          return self.unzip_percy(binary_zip_path, binaryName)

      self.logger.info("Downloading percy binary from {}".format(httpPath))
      response = fire_request('GET', httpPath, {}, {})

      if response.status_code == 200:
        new_etag = response.headers.get("ETag", "")
        if new_etag:
          self.save_etag(percy_binary_dir, new_etag)
        with open(binary_zip_path, 'wb') as file:
          file.write(response.content)
        self.logger.info("Downloaded percy binary and saved at {}".format(binary_zip_path))
        return self.unzip_percy(binary_zip_path, binaryName)
      else:
        raise("Failed to download the file. Status code: {}".format(response.status_code))
    except Exception as e:
      self.logger.error("Unable to download percy binary: {}".format(e))

  def get_percy_binary_path(self, httpPath, binaryName):
    try:
      retry = 2
      percy_binary_path = None
      isValid = False
      while retry > 0:
        percy_binary_path = self.download_percy_binary(httpPath, binaryName)
        isValid = self.validate_percy(httpPath, binaryName, percy_binary_path)
        if isValid:
          break
        retry -= 1
      return percy_binary_path, isValid
    except Exception as e:
      self.logger.error("Unable to get percy binary path".format(e))
    return percy_binary_path, False

  def validate_percy(self, httpPath, binaryName, percy_binary_path, retry_count = 0):
    if retry_count > 1:
      return False

    if percy_binary_path == None or os.path.exists(percy_binary_path) == False:
      self.logger.warn("Percy path not found, retrying download")
      return False
    
    version_regex = r"^.*@percy/cli \d+\.\d+\.\d+" 
    command = '{} --version'.format(percy_binary_path)
    version_check_output = subprocess.check_output(command, shell=True, text=True)
    if re.match(version_regex, version_check_output) != None:
      return True
    else:
      self.logger.error("Percy version check failed")
      # TODO: Delete downloaded binary
      return False

  def unzip_percy(self, binary_zip_path, binaryName):
    try:
      working_dir = os.path.dirname(binary_zip_path)
      shutil.unpack_archive(binary_zip_path, working_dir)
      percy_binary_path = os.path.join(working_dir, binaryName)
      os.chmod(percy_binary_path, 0o755)
      return percy_binary_path
    except Exception as e:
      self.logger.error("Unable to unzip percy binary")
  
  def should_setup_percy(self):
    try:
      percy_config_value = self.config.get('percy')
      should_setup_percy = percy_config_value or (percy_config_value is None and self.is_app_automate)
      if not should_setup_percy or self.config.get('framework', None) not in FULLY_SUPPORTED_PERCY_FRAMEWORKS:
        return False

      self.percy_session = True
      return True
    except Exception as e:
      self.logger.error("Unable to detect percy, Exception {}".format(e))

  def capture_mode(self):
    try:
      capture_mode = self.percy_capture_mode
      return capture_mode
    except Exception as e:
      self.logger.error("Unable to detect percy capture mode, Exception {}".format(e))

  def init(self, is_app_automate, config, logger):
    self.is_app_automate = is_app_automate
    self.config = config
    self.logger = logger
    if not self.should_setup_percy():
      return

    self.percy_options = config.get('percyOptions', {})
    self.percy_capture_mode = config.get('percyCaptureMode')

    try:
      httpPath, binaryName = self.get_percy_uri()
      self.binary_name = binaryName
      percy_binary_path, isValid = self.get_percy_binary_path(httpPath, binaryName)
      if isValid:
        self.binary_path = percy_binary_path
        thread = Thread(target=self.start_percy)
        thread.start()
      else:
        self.setup_failed = True
        self.logger.error("Invalid percy path found - {}, Unable to start Percy".format(percy_binary_path))
    except Exception as e:
      self.logger.error("Unable to start percy, Exception {}".format(e))

  def set_percy_log_path(self):
    try:
      logfile = os.path.join(self.working_dir, 'log', 'percy.log')
      os.makedirs(os.path.dirname(logfile)) if not os.path.exists(os.path.dirname(logfile)) else None
      self.logger.debug("Pushing percy logs at {}".format(logfile))
      self.percy_log_path = logfile
    except Exception as e:
      self.logger.error("Unable to set percy log path, Exception {}".format(e))

  @measure(event_name=EVENTS.SDK_PERCY, stage=STAGE.SINGLE)
  def start_percy(self):
    percy_token = self.fetch_percy_token()
    if percy_token == None:
      self.setup_failed = True
      self.logger.error("Percy token not found, Failed to start percy")
      return False
    
    command_args = ["app:exec:start" if self.is_app_automate else 'exec:start']
    config_path = self.create_percy_config()
    if config_path != None:
      command_args.append("-c {}".format(config_path))

    env = os.environ.copy()
    env["PERCY_TOKEN"] = percy_token
    env["TH_BUILD_UUID"] = os.environ.get('BROWSERSTACK_TESTHUB_UUID', '')
    bin_path = [self.binary_path]
    self.set_percy_log_path()
    self.percy_start_proc = self.run_percy_subprocess(bin_path + command_args, env)
    self.logger.debug("Starting Health Check")
    retry_count = 0
    while self.percy_start_proc.poll() == None:
      healthCheck = self.health_check()
      if healthCheck:
        self.logger.debug("Health Check successful")
        self.is_percy_running = True
        return True

      retry_count += 1
      self.logger.debug("Health Check Retry - {}".format(retry_count))
      time.sleep(2)
    
    self.logger.error("Failed to start percy, Health Check Failed after {} attempts".format(retry_count))
    self.setup_failed = True
    return False

  def health_check(self, retry_count = 0):
    if retry_count > 10:
      return False

    try:
      percy_local_address = os.environ.get('PERCY_SERVER_ADDRESS', 'http://localhost:5338')
      health_check_uri = percy_local_address + PERCY_HEALTH_CHECK_ENDPOINT
      response = requests.get(health_check_uri)
      data = response.json()
      self.percy_build_id = data.get('build', {}).get('id', None)
      return True
    except:
      self.logger.debug("Error occurred while processing health check response")
      return False

  def fetch_percy_token(self):
    product_type = 'app' if self.is_app_automate else 'automate'
    percy_api_param = "undefined" if self.config.get('percy') is None else True

    endpoint = "api/app_percy/get_project_token?name={}&type={}&percy={}".format(self.config['projectName'], product_type, percy_api_param)
    if self.percy_capture_mode:
      endpoint += "&percy_capture_mode={}".format(self.percy_capture_mode)

    uri = bstack_api_url(endpoint)
    try:
      response = fire_request('GET', uri, {}, {'auth': (self.config['userName'], self.config['accessKey'])})
      if response.status_code == 200:
        data = response.json()
        self.percy_session = data.get('success')
        self.percy_capture_mode = data.get('percy_capture_mode')

        os.environ['BROWSERSTACK_PERCY'] = str(self.percy_session)
        os.environ['BROWSERSTACK_PERCY_CAPTURE_MODE'] = str(self.percy_capture_mode)

        if percy_api_param == "undefined" and str(self.percy_session).lower() == "true":
          self.is_auto_enable = True

        if "token" in data:
          return data["token"]
        else:
          raise 'Token Not Found - {}'.format(data)
      else:
        raise "Failed to fetch percy token, Response status - {}, Response Body - {}".format(response.status_code, response.json())
    except Exception as e:
      self.logger.error("Exception in creating percy project".format(e))

  def create_percy_config(self):
    percy_conf_path = os.path.join(tempfile.gettempdir(), "percyConfig.json")
    try:
      if 'version' not in self.percy_options:
        self.percy_options['version'] = 2
      with open(percy_conf_path, 'w') as fp:
        json.dump(self.percy_options, fp)
      return percy_conf_path
    except Exception as e:
      self.logger.error("Unable to create percy conf, Exception {}".format(e))

  def run_percy_subprocess(self, cmd, env = os.environ.copy()):
    try:
      if self.hostType == 'win':
        windows_helper_cmd = ['cmd.exe', '/c']
        cmd = windows_helper_cmd + cmd

      cmd = ' '.join(cmd)
      self.logger.debug("Running {}".format(cmd))
      with open(self.percy_log_path, "a") as log_stream:
        process = subprocess.Popen(cmd, shell=True, stdout=log_stream, text=True, stderr=log_stream, env=env, universal_newlines=True)

      return process
    except Exception as e:
      self.setup_failed = True
      self.logger.error("Failed to start percy with cmd - {}, Exception: {}".format(cmd, e))

  def shutdown(self):
    try:
      if self.is_percy_running:
        self.logger.info("Stopping Percy")
        cmd = [self.binary_path, "exec:stop"]
        self.run_percy_subprocess(cmd)
        self.is_percy_running = False
    except Exception as e:
      self.logger.error("Failed to stop session with command - {}, Exception: {}".format(cmd, e))

  def wait_for_percy_setup(self):
    if not self.percy_session:
      return

    try:
      wait_count = 0
      while not self.is_percy_running and wait_count < self.percy_start_wait_count:
        if self.setup_failed:
          self.logger.info("Percy setup failed")
          return

        time.sleep(1)
        wait_count += 1
      os.environ['PERCY_BEST_PLATFORM'] = str(self.get_best_platform())
      self.logger.info("Percy setup completed")
    except Exception as e:
      self.logger.error("Unable to setup percy, Exception {}".format(e))
  
  def get_best_platform(self):
    if self.is_app_automate:
      return

    try:
      user_browser_list = [platform['browserName'].lower() for platform in self.config.get('platforms', [])]
      rank = sys.maxsize
      best_browser = ''
      for browser in user_browser_list:
        if browser in self.browser_rank:
          current_browser_rank = self.browser_rank[browser]
        if current_browser_rank < rank:
          rank = current_browser_rank
          best_browser = browser
      return best_browser
    except Exception as e:
      self.logger.error("Unable to find best platform, Exception {}".format(e))

  @classmethod
  def is_percy(self):
    return os.getenv('BROWSERSTACK_PERCY', 'False').lower()

  @classmethod
  def get_percy_capture_mode(self):
    return os.getenv('BROWSERSTACK_PERCY_CAPTURE_MODE', '')
  
  @classmethod
  def set_percy_auto_enable(cls, value):
    cls.is_auto_enable = value
  
  @classmethod
  def get_percy_auto_enable(cls):
    return cls.is_auto_enable

  @classmethod
  def set_percy_build_id(cls, value):
    cls.percy_build_id = value
  
  @classmethod
  def get_percy_build_id(cls):
    return cls.percy_build_id
